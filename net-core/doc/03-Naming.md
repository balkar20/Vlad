# Именование


## Проект и его подпроекты


Проект состоит из набора связанных друг с другом подпроектов, каждый из которых реализует
конкретную функциональность на конкретном стеке технологий с использованием конкретных библиотек.
Каждый из этих подпроектов содержится в отдельной папке со следующей структурой имени:
<Кто>.<Где>.<Зачем>.<Чем>. Последняя часть <Чем> в имени не обязательна. 


### <Кто>


Первая часть у всех одинакова: Vlad2020. Это имя проекта.


### <Где>


Подпроекты сгруппированы по слоям. Если представить проект в виде ступенчатой пирамиды, то слой -
это ступенька, то есть место, ГДЕ находится подпроект с точки зрения иерархии подчинения:


#### Apps


Приложения - набор подпроектов, реализующих интерфейс пользователя на конкретной платформе.
Это слой представления, привязанный к конкретным библиотекам, предназначенным для визуализации.


#### Core


Ядро - базовая функциональность, на которую опираются все остальные слои.


#### Data


Данные - здесь всё, что нужно для обеспечения связи с источниками данных и их настройкой.


#### Host


Хост - обеспечивает базовую бизнес-логику.


#### Mods.<Имя мода>


Моды - обеспечивают дополнительную бизнес-логику через набор независимых друг от друга функциональных модулей.


#### Root


Корень - обеспечивает базовую логику представления. Слово "базовая" означает, что она может быть применена
ко всем приложениям - подпроектам слоя Apps.


### <Зачем>


В каждом слое подпроекты сгруппированы по назначению - тому, ЗАЧЕМ они помещены на данную ступеньку иерархии
(слой):


#### Base


Основа - обязательная функциональность.


#### Caching


Кэширование - функциональность, связанная с кэшированием данных: сериализация, хранение, инвалидация.


#### Common


Общее - общая функциональность.


#### Entity


Объектно-реляционое отображение на основе технологии Entity Framework - позволяет работать с данными без
привязки к конкретной реляционной базе данных.


#### Web


Веб - функциональность, связанная с веб-интерфейсом.


### <Чем>


Назначение может быть реализовано с помощью разных однотипных иструментов и то,
ЧЕМ реализовано конкретное назначение - конкретной библиотекой или технологией,
описывает последняя необязательная часть имени подпроекта:


#### Entity.SqlServer


Объектно-реляционное отображение Entity Framework на базу данных MS SQL Server:
https://www.microsoft.com/en-us/sql-server/sql-server-2017


## Файлы, папки и элементы языка программирования


Исходный код подпроектов написан на трёх языках программирования: TypeScript, JavaScript и C#.
В каждом из них существуют свои правила именования папок, файлов и сущностей, описанных в них.
Если кратко, то здесь всё стандартно. Ниже описано только то, на чём следует заострить внимание.


### Имена пространств имён в C#


Должны начинаться с полного имени подпроекта и далее описывать их назначение словами, разделёнными точкой.
При выборе слов для обозначения частей пространств имён нужно стараться находить максимально короткие,
а также использовать общеупотребительные сокращения, если они уместны и не приведут к двусмысленному толкованию.

Пример:

    Aaa.Bbb.Ccc.Ddd


### Имена классов в C#


Должны начинаться с полного имени пространства имён с удалёнными из него точками.
При этом раздел <Кто> из имени класса должен быть исключён, то есть первым словом в имени класса
будет имя слоя (раздел <Где>). Все слова из полного имени пространства имён, употреблённые
во множественном числе, в имени класса должны быть употреблены в единственном числе.

Пример:

    AaaBbbCccDdd
    
    Это имя класса в пространстве имён Vlad2020.Aaa.Bbbs.Ccc,
    где Bbbs - это Bbb во множественном числе.


### Имена констант в C#


Должны состоять только из заглавных букв. Отдельные слова в них должны отделяться друг от друга
символом нижнего подчёркивания.

Пример:

    AAA_BBB_CCC


### Имена файлов в C#


Должны совпадать с именем элемента языка, описанного в нём. Все слова в имени, кроме последнего,
должны совпадать со словами в единственном числе, составляющими имена папок, внутри которых
находится файл, в порядке их вложенности.

Пример:

    AaaBbbCccDdd.cs

    Файл с этим именем должен находиться в папке Aaa/Bbbs/Ccc,
    где Bbbs - это Bbb во множественном числе.


### Имена папок в C#


Должны совпадать с частями пространств имён, разделёнными точками. 

Пример:

    Aaa/Bbb/Ccc

    Все файлы классов в пространстве имён Aaa.Bbb.Ccc должны находиться в этой папке.


### Имена файлов в JavaScript и TypeScript


Должны быть в нижнем регистре. Отдельные слова должны быть отделены друг от друга дефисом. Если файл
описывает стандартную для используемой технологии сущность, её название должно быть в конце имени
файла и отделено от остальной его части точкой. 

Пример:

    aaa-bbb.service.ts
    
    В данном случае "service" - это стандартная сущность для технологии Angular. 

Или:

    aaa-bbb-ccc.component.js
    
    aaa-bbb-ccc.component.ts
    
    В данном случае "component"- это стандартная сущность для технологий ReactJS и Angular.


### Имена папок в JavaScript и TypeScript


Должны состоять из слов, состоящих из букв в нижнем регистре. Слова должны быть отделены друг от друга дефисом.
Название папки должно быть атомарным, то есть оно должно содержать несколько разделённых дефисами слов только
в том случае, если его сокращение приведёт к двусмысленному толкованию. 

Пример:

    aaa/bbb-ccc/ddd


### Имена классов в JavaScript и TypeScript


Даются по тому же принципу, что и имена классов в C#, только вместо частей пространства имён в них
употребляются имена папок, внутри которых находится файл класса. 

Пример: 

    AaaBbbCccDdd
    
    Это имя класса в файлах aaa-bbb-ccc-ddd.js или aaa-bbb-ccc-ddd.ts,
    размещённых в папке aaa/bbbs/ccc, где bbbs - это bbb во множественном числе.


### Имена экспортируемых переменных и функций в JavaScript и TypeScript


Даются по тому же принципу, что и имена классов в в JavaScript и TypeScript, только начинаются с
маленькой буквы.

Пример:

    aaaBbbCccDdd


### Имена констант в JavaScript и TypeScript


Либо как в C#, либо как имена экспортируемых переменных в JavaScript и TypeScript.
При выборе одного из вариантов его для единообразия нужно использовать повсеместно без исключений.


## Комментарии


### В C#


В C# комментарии обязательны для все открытых и защищённых членов класса, для всех классов и перечислений,
а также членов перечислений. 

Например, для класса CoreBaseContext в пространстве имён Vlad2020.Core.Base комментарий может быть таким:

    /// <summary>
    /// Ядро. Основа. Контекст.
    /// </summary>

А для открытого метода GetError из этого же класса с одним аргументом exception комментарий может быть таким:

    /// <summary>
    /// Получение ошибки.
    /// </summary>
    /// <param name="exception">Исключение, приведшее к возникновению ошибки.</param>
    /// <returns>Ошибка.</returns>


### В JavaScript и TypeScript

В JavaScript и TypeScript комментарии обязательны для всех экспортируемых элементов языка
(классов, переменных, функций и так далее), а также для всех открытых членов класса.
Комментарии должны быть в формате jsDoc: http://usejsdoc.org/.
Они должны быть максимально полными с обязательным указанием типов членов класса,
параметров функций и возвращаемых значений.
Дело в том, что без них специализированные редакторы не смогут узнать тип элемента языка,
дать подсказку и уберечь от ошибок в коде, написанном на JavaScript.
В силу того, что возможен вариант, когда исходный код из TypeScript будет переводиться в
JavaScript, отсутствие полноценных комментариев с указаним типа приведёт к серьёзным проблемам
при адаптации.

Пример комментария для класса CoreLoggingService из файла core-logging.service.js,
размещённого в папке app/core/logging:

    /** Ядро. Логирование. Сервис. */

Пример комментария для конструктора этого же класса:

    /**
     * Конструктор.
     * @param {string} name Имя.
     * @param {CoreLoggingConfig} config Конфигурация.
     */

Пример комментария закрытого метода transformMessage из этого же класса (типы возвращаемого значения и
параметра указаны, а описание - нет, так как закрытые методы описывать необязательно):

    /**
     * @param {string} message
     * @returns {string}
     */

Пример комментария открытого метода logError из этого же класса (указаны и описание и типы параметров,
так как для открытых членов класса это обязательно):

    /**
     * Зарегистрировать ошибку.
     * @param {string} message Сообщение.
     * @param {?any} data Данные.
     */
